# Copyright 2022 Canonical Ltd.
# See LICENSE file for licensing details.

"""Pgbouncer backend-database relation hooks & helpers.

This relation expects that usernames and passwords are generated and provided by the PostgreSQL
charm.

Some example relation data is below. The only parts of this we actually need are the "endpoints"
and "read-only-endpoints" fields. All values are examples taken from a test deployment, and are
not definite.

Example:
┏━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┓
┃ category         ┃             keys ┃ pgbouncer-k8s-o… ┃ postgresql-k8s/0 ┃
┡━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━┩
│ metadata         │         endpoint │ 'backend-databa… │ 'database'       │
│                  │           leader │ True             │ True             │
├──────────────────┼──────────────────┼──────────────────┼──────────────────┤
│ application data │             data │ {"endpoints":    │ {"database":     │
│                  │                  │ "postgresql-k8s… │ "postgresql",    │
│                  │                  │ "password":      │ "extra-user-rol… │
│                  │                  │ "18cqKCp19xOPBh… │ "SUPERUSER"}     │
│                  │                  │ "read-only-endp… │                  │
│                  │                  │ "postgresql-k8s… │                  │
│                  │                  │ "username":      │                  │
│                  │                  │ "relation_id_18… │                  │
│                  │                  │ "version":       │                  │
│                  │                  │ "12.9"}          │                  │
│                  │         database │ pgbouncer        │                  │
│                  │        endpoints │                  │ postgresql-k8s-… │
│                  │ extra-user-roles │ SUPERUSER        │                  │
│                  │         password │                  │ 18cqKCp19xOPBhk9 │
│                  │ read-only-endpo… │                  │ postgresql-k8s-… │
│                  │         username │                  │ relation_id_18   │
│                  │          version │                  │ 12.9             │
└──────────────────┴──────────────────┴──────────────────┴──────────────────┘
"""

import logging
from typing import Union

from charms.data_platform_libs.v0.database_requires import (
    DatabaseCreatedEvent,
    DatabaseEndpointsChangedEvent,
    DatabaseReadOnlyEndpointsChangedEvent,
    DatabaseRequires,
)
from charms.pgbouncer_k8s.v0 import pgb
from charms.postgresql_k8s.v0.postgresql import PostgreSQL
from ops.charm import CharmBase, RelationBrokenEvent, RelationDepartedEvent
from ops.framework import Object

RELATION_NAME = "backend-database"
PGB_DIR = "/var/lib/postgresql/pgbouncer"
USERLIST_PATH = f"{PGB_DIR}/userlist.txt"


logger = logging.getLogger(__name__)


class BackendDatabaseRequires(Object):
    """Defines functionality for the 'requires' side of the 'backend-database' relation.

    The data created in this relation allows the pgbouncer charm to connect to the postgres charm.

    Hook events observed:
        - database-created
        - database-endpoints-changed
        - database-read-only-endpoints-changed
        - relation-departed
        - relation-broken
    """

    def __init__(self, charm: CharmBase):
        super().__init__(charm, RELATION_NAME)

        self.charm = charm
        self.database = DatabaseRequires(
            self.charm,
            relation_name=RELATION_NAME,
            database_name="pgbouncer",
            extra_user_roles="SUPERUSER",
        )

        self.framework.observe(self.database.on.database_created, self._on_database_created)
        self.framework.observe(self.database.on.endpoints_changed, self._on_endpoints_changed)
        self.framework.observe(
            self.database.on.read_only_endpoints_changed, self._on_endpoints_changed
        )
        self.framework.observe(charm.on[RELATION_NAME].relation_broken, self._on_relation_broken)

    def _on_database_created(self, event: DatabaseCreatedEvent) -> None:
        """Handle backend-database-database-created event.

        Accesses user and password generated by the postgres charm and adds a user.
        """
        logger.info("initialising postgres and pgbouncer relations")
        logger.info("initialising auth user")

        logger.error(event.relation.data)
        logger.error(dir(event))
        logger.error(event.relation.app)

        postgres = self.get_postgres(
            event.endpoints.split(":")[0], event.username, event.password, self.database.database
        )
        # TODO this may be bad
        if postgres == None:
            event.defer()
            logging.error("deferring database-created hook - postgres database not ready")
            return

        auth_user = f"pgbouncer_auth_{event.username}"
        install_script = open("src/relations/pgbouncer-install.sql", "r").read()

        with postgres.connect_to_database() as conn, conn.cursor() as cursor:
            cursor.execute(install_script.replace("pgbouncer", auth_user))
        conn.close()

        cfg = self.charm.read_pgb_config()
        cfg.add_user(user=event.username, admin=True)
        cfg["pgbouncer"]["auth_user"] = auth_user
        cfg["pgbouncer"]["auth_query"] = f"SELECT username, password FROM {auth_user}.get_auth($1)"
        # TODO maybe don't reload if we're updating endpoints
        self.charm._render_pgb_config(cfg, reload_pgbouncer=True)

        logger.info("auth user created")

        # TODO this doesn't do anything yet. Get endpoints from relation
        self.charm.update_postgres_endpoints()

    def _on_endpoints_changed(
        self, _: Union[DatabaseEndpointsChangedEvent, DatabaseReadOnlyEndpointsChangedEvent]
    ):
        # TODO this doesn't do anything yet. Get endpoints from relation
        self.charm.update_postgres_endpoints()

    def _on_relation_departed(self, event: RelationDepartedEvent):
        if event.departing_unit != self.charm.unit:
            return

        logger.info("removing auth user")

        databag = event.relation.data[event.app]
        username = databag.get("username")
        postgres = self.get_postgres(
            databag.get("endpoints").split(":")[0],
            username,
            databag.get("password"),
            databag.get("database"),
        )
        sql_file = open("src/relations/pgbouncer-uninstall.sql", "r").read()
        auth_user = f"pgbouncer_auth_{username}"
        with postgres.connect_to_database() as conn, conn.cursor() as cursor:
            # TODO prepend a unique username to this file
            cursor.execute(sql_file.replace("auth_user", auth_user))
        conn.close()
        logger.info("auth user removed")

    def _on_relation_broken(self, _: RelationBrokenEvent):
        """Handle backend-database-relation-broken event.

        Removes all traces of this relation from pgbouncer config.
        """
        # from pdb import set_trace; set_trace()

        cfg = self.charm.read_pgb_config()
        cfg.remove_user(self.charm.backend_postgres.user)
        # TODO pop still gets keyerror?
        cfg["pgbouncer"].pop("auth_user", None)
        cfg["pgbouncer"].pop("auth_query", None)
        # TODO maybe don't reload if we're updating endpoints
        self.charm._render_pgb_config(cfg, reload_pgbouncer=True)

        # TODO this doesn't update the endpoints yet, because they're only updated when this
        # hook ends.
        self.charm.update_postgres_endpoints()

    def get_postgres(self, host, user, password, database):
        if None in [host, user, password, database]:
            return None

        return PostgreSQL(host=host, user=user, password=password, database=database)
